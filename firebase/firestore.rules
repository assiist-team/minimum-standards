rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function hasOnlyKeys(allowedKeys) {
      return request.resource.data.keys().hasOnly(allowedKeys);
    }

    function isTimestamp(value) {
      return value is timestamp;
    }

    function isOptionalTimestampField(fieldName) {
      return !(fieldName in request.resource.data) ||
        request.resource.data[fieldName] == null ||
        isTimestamp(request.resource.data[fieldName]);
    }

    function isOptionalStringField(fieldName) {
      return !(fieldName in request.resource.data) ||
        request.resource.data[fieldName] == null ||
        request.resource.data[fieldName] is string;
    }

    function validSessionConfig() {
      return ('sessionConfig' in request.resource.data)
        && request.resource.data.sessionConfig is map
        && request.resource.data.sessionConfig.keys().hasOnly([
          'sessionLabel',
          'sessionsPerCadence',
          'volumePerSession'
        ])
        && request.resource.data.sessionConfig.sessionLabel is string
        && request.resource.data.sessionConfig.sessionLabel.size() >= 1
        && request.resource.data.sessionConfig.sessionLabel.size() <= 60
        && request.resource.data.sessionConfig.sessionsPerCadence is int
        && request.resource.data.sessionConfig.sessionsPerCadence >= 1
        && request.resource.data.sessionConfig.sessionsPerCadence <= 1000
        && request.resource.data.sessionConfig.volumePerSession is number
        && request.resource.data.sessionConfig.volumePerSession > 0;
    }

    function isCreateWithServerTimestamps() {
      // Enforces client use of serverTimestamp(); in rules it resolves to request.time.
      return request.resource.data.createdAt == request.time && request.resource.data.updatedAt == request.time;
    }

    function isUpdateWithServerTimestampAndStableCreatedAt() {
      return request.resource.data.updatedAt == request.time &&
        request.resource.data.createdAt == resource.data.createdAt;
    }

    function validActivity() {
      return hasOnlyKeys([
        'name',
        'unit',
        'notes',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && request.resource.data.name is string
      && request.resource.data.name.size() >= 1
      && request.resource.data.name.size() <= 120
      && request.resource.data.unit is string
      && request.resource.data.unit.size() >= 1
      && request.resource.data.unit.size() <= 40
      && isOptionalStringField('notes')
      && (!('notes' in request.resource.data) || request.resource.data.notes == null || request.resource.data.notes.size() <= 1000)
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('deletedAt');
    }

    // Validation for partial updates (allows updating only specific fields)
    function validActivityUpdate() {
      return hasOnlyKeys([
        'name',
        'unit',
        'notes',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && (!('name' in request.resource.data) || (
        request.resource.data.name is string
        && request.resource.data.name.size() >= 1
        && request.resource.data.name.size() <= 120
      ))
      && (!('unit' in request.resource.data) || (
        request.resource.data.unit is string
        && request.resource.data.unit.size() >= 1
        && request.resource.data.unit.size() <= 40
      ))
      && (!('notes' in request.resource.data) || (
        isOptionalStringField('notes')
        && (request.resource.data.notes == null || request.resource.data.notes.size() <= 1000)
      ))
      && (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt)
      && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt == request.time)
      && (!('deletedAt' in request.resource.data) || isOptionalTimestampField('deletedAt'));
    }

    function validStandard() {
      return hasOnlyKeys([
        'activityId',
        'minimum',
        'unit',
        'cadence',
        'state',
        'summary',
        'sessionConfig',
        'quickAddValues',
        'archivedAt',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && request.resource.data.activityId is string
      && request.resource.data.activityId.size() >= 1
      && request.resource.data.minimum is number
      && request.resource.data.minimum >= 0
      && request.resource.data.unit is string
      && request.resource.data.unit.size() >= 1
      && request.resource.data.unit.size() <= 40
      && (
        !('quickAddValues' in request.resource.data)
        || (
          request.resource.data.quickAddValues is list
          && request.resource.data.quickAddValues.size() <= 5
        )
      )
      && request.resource.data.cadence is map
      && request.resource.data.cadence.keys().hasOnly(['interval', 'unit'])
      && request.resource.data.cadence.interval is int
      && request.resource.data.cadence.interval > 0
      && request.resource.data.cadence.unit in ['day', 'week', 'month']
      && request.resource.data.state in ['active', 'archived']
      && request.resource.data.summary is string
      && request.resource.data.summary.size() >= 1
      && request.resource.data.summary.size() <= 200
      && validSessionConfig()
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('deletedAt')
      && isOptionalTimestampField('archivedAt');
    }

    // Block writes to Standards that remain archived, while allowing archive + unarchive transitions.
    function canWriteStandard() {
      let wasArchived = resource.data.archivedAt != null;
      let willBeArchived = request.resource.data.archivedAt != null;

      // Writes are always allowed while the standard is active (wasArchived == false).
      // Once archived, the only permitted write is to clear archivedAt (unarchive).
      return !wasArchived || !willBeArchived;
    }

    function validActivityLog() {
      return hasOnlyKeys([
        'standardId',
        'value',
        'occurredAt',
        'note',
        'createdAt',
        'updatedAt',
        'editedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && ('note' in request.resource.data)
      && ('editedAt' in request.resource.data)
      && request.resource.data.standardId is string
      && request.resource.data.standardId.size() >= 1
      && request.resource.data.value is number
      && request.resource.data.value >= 0
      && isTimestamp(request.resource.data.occurredAt)
      && isOptionalStringField('note')
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('editedAt')
      && isOptionalTimestampField('deletedAt');
    }

    // Validation for partial updates (allows updating only editedAt/deletedAt/updatedAt and other fields)
    function validActivityLogUpdate() {
      return hasOnlyKeys([
        'standardId',
        'value',
        'occurredAt',
        'note',
        'createdAt',
        'updatedAt',
        'editedAt',
        'deletedAt'
      ])
      && (!('standardId' in request.resource.data) || (
        request.resource.data.standardId is string
        && request.resource.data.standardId.size() >= 1
        && request.resource.data.standardId == resource.data.standardId
      ))
      && (!('value' in request.resource.data) || (
        request.resource.data.value is number
        && request.resource.data.value >= 0
      ))
      && (!('occurredAt' in request.resource.data) || isTimestamp(request.resource.data.occurredAt))
      && (!('note' in request.resource.data) || isOptionalStringField('note'))
      && (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt)
      && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt == request.time)
      && (!('editedAt' in request.resource.data) || isOptionalTimestampField('editedAt'))
      && (!('deletedAt' in request.resource.data) || isOptionalTimestampField('deletedAt'));
    }

    function canCreateLogForStandard(uid, standardId) {
      let standardDoc = get(/databases/$(database)/documents/users/$(uid)/standards/$(standardId));
      return standardDoc.data != null && standardDoc.data.archivedAt == null;
    }

    function validDashboardPins() {
      return hasOnlyKeys([
        'pinnedStandardIds',
        'updatedAt'
      ])
      && ('pinnedStandardIds' in request.resource.data)
      && request.resource.data.pinnedStandardIds is list
      && request.resource.data.pinnedStandardIds.size() <= 1000
      && ('updatedAt' in request.resource.data)
      && isTimestamp(request.resource.data.updatedAt);
    }

    function validDashboardPinsCreate() {
      // For creates, updatedAt must be set to request.time (serverTimestamp)
      return validDashboardPins() && 
        request.resource.data.updatedAt == request.time;
    }

    function validDashboardPinsUpdate() {
      // For updates, updatedAt must be set to request.time (serverTimestamp)
      // pinnedStandardIds can be updated
      return validDashboardPins() && 
        request.resource.data.updatedAt == request.time;
    }

    match /users/{uid} {
      allow read: if isOwner(uid);
      // Prevent client from directly writing the user root doc in MVP.
      allow create, update, delete: if false;

      match /activities/{activityId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validActivity() && isCreateWithServerTimestamps();
        allow update: if isOwner(uid) && validActivityUpdate() && isUpdateWithServerTimestampAndStableCreatedAt();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /standards/{standardId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validStandard() && isCreateWithServerTimestamps();
        allow update: if isOwner(uid) && validStandard() && isUpdateWithServerTimestampAndStableCreatedAt() && canWriteStandard();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /activityLogs/{logId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validActivityLog() && isCreateWithServerTimestamps() && canCreateLogForStandard(uid, request.resource.data.standardId);
        allow update: if isOwner(uid) && validActivityLogUpdate() && isUpdateWithServerTimestampAndStableCreatedAt();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /preferences/{preferenceId} {
        // Only allow dashboardPins document in preferences collection
        allow read: if isOwner(uid) && preferenceId == 'dashboardPins';
        // Allow create and update (set with merge handles both)
        allow create: if isOwner(uid) && preferenceId == 'dashboardPins' && validDashboardPinsCreate();
        allow update: if isOwner(uid) && preferenceId == 'dashboardPins' && validDashboardPinsUpdate();
        allow delete: if false; // Prevent deletion, use empty array instead
      }
    }
  }
}
