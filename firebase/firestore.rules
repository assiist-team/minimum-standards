rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function hasOnlyKeys(allowedKeys) {
      return request.resource.data.keys().hasOnly(allowedKeys);
    }

    function isTimestamp(value) {
      return value is timestamp;
    }

    function isTimestampMs(value) {
      return value is int && value >= 0;
    }

    function isOptionalTimestampField(fieldName) {
      return !(fieldName in request.resource.data) ||
        request.resource.data[fieldName] == null ||
        isTimestamp(request.resource.data[fieldName]);
    }

    function isOptionalStringField(fieldName) {
      return !(fieldName in request.resource.data) ||
        request.resource.data[fieldName] == null ||
        request.resource.data[fieldName] is string;
    }

    function validSessionConfig(sessionConfig) {
      return sessionConfig is map
        && sessionConfig.keys().hasOnly([
          'sessionLabel',
          'sessionsPerCadence',
          'volumePerSession'
        ])
        && sessionConfig.sessionLabel is string
        && sessionConfig.sessionLabel.size() >= 1
        && sessionConfig.sessionLabel.size() <= 40
        && sessionConfig.sessionsPerCadence is int
        && sessionConfig.sessionsPerCadence >= 1
        && sessionConfig.sessionsPerCadence <= 1000
        && sessionConfig.volumePerSession is number
        && sessionConfig.volumePerSession > 0;
    }

    function validPeriodStartPreference(preference) {
      return preference is map
        && ('mode' in preference)
        && (
          preference.mode == 'default'
          || (
            preference.mode == 'weekDay'
            && 'weekStartDay' in preference
            && preference.weekStartDay is int
            && preference.weekStartDay >= 1
            && preference.weekStartDay <= 7
          )
        );
    }

    function isCreateWithServerTimestamps() {
      // Enforces client use of serverTimestamp(); in rules it resolves to request.time.
      return request.resource.data.createdAt == request.time && request.resource.data.updatedAt == request.time;
    }

    function isUpdateWithServerTimestampAndStableCreatedAt() {
      return request.resource.data.updatedAt == request.time &&
        request.resource.data.get('createdAt', null) == resource.data.get('createdAt', null);
    }

    function validActivity() {
      return hasOnlyKeys([
        'name',
        'unit',
        'notes',
        'categoryId',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && request.resource.data.name is string
      && request.resource.data.name.size() >= 1
      && request.resource.data.name.size() <= 120
      && request.resource.data.unit is string
      && request.resource.data.unit.size() >= 1
      && request.resource.data.unit.size() <= 40
      && isOptionalStringField('notes')
      && (!('notes' in request.resource.data) || request.resource.data.notes == null || request.resource.data.notes.size() <= 1000)
      && (
        !('categoryId' in request.resource.data)
        || request.resource.data.categoryId == null
        || (request.resource.data.categoryId is string && request.resource.data.categoryId.size() >= 1)
      )
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('deletedAt');
    }

    // Validation for partial updates (allows updating only specific fields)
    function validCategory() {
      return hasOnlyKeys([
        'name',
        'order',
        'isSystem',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && request.resource.data.name is string
      && request.resource.data.name.size() >= 1
      && request.resource.data.name.size() <= 120
      && request.resource.data.order is int
      && request.resource.data.order >= 0
      && (
        !('isSystem' in request.resource.data)
        || request.resource.data.isSystem is bool
      )
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('deletedAt');
    }

    function validCategoryUpdate() {
      let affected = request.resource.data.diff(resource.data).affectedKeys();
      return affected.hasOnly([
        'name',
        'order',
        'isSystem',
        'updatedAt',
        'deletedAt'
      ])
      && (
        !affected.hasAny(['name']) || (
          'name' in request.resource.data
          && request.resource.data.name is string
          && request.resource.data.name.size() >= 1
          && request.resource.data.name.size() <= 120
        )
      )
      && (
        !affected.hasAny(['order']) || (
          'order' in request.resource.data
          && request.resource.data.order is int
          && request.resource.data.order >= 0
        )
      )
      && (
        !affected.hasAny(['isSystem']) || (
          'isSystem' in request.resource.data
          && request.resource.data.isSystem is bool
        )
      )
      && (
        !affected.hasAny(['updatedAt']) || request.resource.data.updatedAt == request.time
      )
      && (
        !affected.hasAny(['deletedAt']) || isOptionalTimestampField('deletedAt')
      );
    }

    function validActivityUpdate() {
      let affected = request.resource.data.diff(resource.data).affectedKeys();
      return affected.hasOnly([
        'name',
        'unit',
        'notes',
        'categoryId',
        'updatedAt',
        'deletedAt'
      ])
      && (
        !affected.hasAny(['name']) || (
          'name' in request.resource.data
          && request.resource.data.name is string
          && request.resource.data.name.size() >= 1
          && request.resource.data.name.size() <= 120
        )
      )
      && (
        !affected.hasAny(['unit']) || (
          'unit' in request.resource.data
          && request.resource.data.unit is string
          && request.resource.data.unit.size() >= 1
          && request.resource.data.unit.size() <= 40
        )
      )
      && (
        !affected.hasAny(['notes']) || (
          isOptionalStringField('notes')
          && (!('notes' in request.resource.data) || request.resource.data.notes == null || request.resource.data.notes.size() <= 1000)
        )
      )
      && (
        !affected.hasAny(['categoryId']) || (
          !('categoryId' in request.resource.data)
          || request.resource.data.categoryId == null
          || (request.resource.data.categoryId is string && request.resource.data.categoryId.size() >= 1)
        )
      )
      && (
        !affected.hasAny(['updatedAt']) || request.resource.data.updatedAt == request.time
      )
      && (
        !affected.hasAny(['deletedAt']) || isOptionalTimestampField('deletedAt')
      );
    }

    function validStandard() {
      return hasOnlyKeys([
        'activityId',
        'minimum',
        'unit',
        'cadence',
        'state',
        'summary',
        'sessionConfig',
        'periodStartPreference',
        'quickAddValues',
        'categoryId',
        'archivedAt',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && request.resource.data.activityId is string
      && request.resource.data.activityId.size() >= 1
      && request.resource.data.minimum is number
      && request.resource.data.minimum >= 0
      && request.resource.data.unit is string
      && request.resource.data.unit.size() >= 1
      && request.resource.data.unit.size() <= 40
      && (
        !('quickAddValues' in request.resource.data)
        || (
          request.resource.data.quickAddValues is list
          && request.resource.data.quickAddValues.size() <= 5
        )
      )
      && request.resource.data.cadence is map
      && request.resource.data.cadence.keys().hasOnly(['interval', 'unit'])
      && request.resource.data.cadence.interval is int
      && request.resource.data.cadence.interval > 0
      && request.resource.data.cadence.unit in ['day', 'week', 'month']
      && request.resource.data.state in ['active', 'archived']
      && request.resource.data.summary is string
      && request.resource.data.summary.size() >= 1
      && request.resource.data.summary.size() <= 200
      && ('sessionConfig' in request.resource.data)
      && validSessionConfig(request.resource.data.sessionConfig)
      && (
        !('periodStartPreference' in request.resource.data)
        || validPeriodStartPreference(request.resource.data.periodStartPreference)
      )
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('deletedAt')
      && isOptionalTimestampField('archivedAt')
      && (
        !('categoryId' in request.resource.data)
        || request.resource.data.categoryId == null
        || (request.resource.data.categoryId is string && request.resource.data.categoryId.size() >= 1)
      );
    }

    // Allow edits while archived, but prevent archivedAt changes except unarchive.
    function canWriteStandard() {
      let wasArchived = resource.data.archivedAt != null;
      let willBeArchived = request.resource.data.archivedAt != null;
      // Active standards: always writable. Archived: only if archivedAt stays the same
      // or unarchive by clearing archivedAt.
      return !wasArchived
        || !willBeArchived
        || request.resource.data.archivedAt == resource.data.archivedAt;
    }

    function validActivityLog() {
      return hasOnlyKeys([
        'standardId',
        'value',
        'occurredAt',
        'note',
        'createdAt',
        'updatedAt',
        'editedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && ('note' in request.resource.data)
      && ('editedAt' in request.resource.data)
      && request.resource.data.standardId is string
      && request.resource.data.standardId.size() >= 1
      && request.resource.data.value is number
      && request.resource.data.value >= 0
      && isTimestamp(request.resource.data.occurredAt)
      && isOptionalStringField('note')
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('editedAt')
      && isOptionalTimestampField('deletedAt');
    }

    // Validation for partial updates (allows updating only editedAt/deletedAt/updatedAt and other fields)
    function validActivityLogUpdate() {
      let affected = request.resource.data.diff(resource.data).affectedKeys();
      return affected.hasOnly([
        'standardId',
        'value',
        'occurredAt',
        'note',
        'updatedAt',
        'editedAt',
        'deletedAt'
      ])
      && (
        !affected.hasAny(['standardId']) || (
          'standardId' in request.resource.data
          && request.resource.data.standardId is string
          && request.resource.data.standardId.size() >= 1
          && request.resource.data.standardId == resource.data.standardId
        )
      )
      && (
        !affected.hasAny(['value']) || (
          'value' in request.resource.data
          && request.resource.data.value is number
          && request.resource.data.value >= 0
        )
      )
      && (
        !affected.hasAny(['occurredAt']) || isTimestamp(request.resource.data.occurredAt)
      )
      && (
        !affected.hasAny(['note']) || isOptionalStringField('note')
      )
      && (
        !affected.hasAny(['updatedAt']) || request.resource.data.updatedAt == request.time
      )
      && (
        !affected.hasAny(['editedAt']) || isOptionalTimestampField('editedAt')
      )
      && (
        !affected.hasAny(['deletedAt']) || isOptionalTimestampField('deletedAt')
      );
    }

    function canCreateLogForStandard(uid, standardId) {
      let standardDoc = get(/databases/$(database)/documents/users/$(uid)/standards/$(standardId));
      return standardDoc.data != null && standardDoc.data.archivedAt == null;
    }

    function validDashboardPins() {
      return hasOnlyKeys([
        'pinnedStandardIds',
        'updatedAt'
      ])
      && ('pinnedStandardIds' in request.resource.data)
      && request.resource.data.pinnedStandardIds is list
      && request.resource.data.pinnedStandardIds.size() <= 1000
      && ('updatedAt' in request.resource.data)
      && isTimestamp(request.resource.data.updatedAt);
    }

    function validDashboardPinsCreate() {
      // For creates, updatedAt must be set to request.time (serverTimestamp)
      return validDashboardPins() && 
        request.resource.data.updatedAt == request.time;
    }

    function validDashboardPinsUpdate() {
      // For updates, updatedAt must be set to request.time (serverTimestamp)
      // pinnedStandardIds can be updated
      return validDashboardPins() && 
        request.resource.data.updatedAt == request.time;
    }

    function validActivityHistoryStandardSnapshot(snapshot) {
      return snapshot is map
        && snapshot.keys().hasOnly([
          'minimum',
          'unit',
          'cadence',
          'sessionConfig',
          'summary',
          'periodStartPreference'
        ])
        && snapshot.minimum is number
        && snapshot.minimum >= 0
        && snapshot.unit is string
        && snapshot.unit.size() >= 1
        && snapshot.unit.size() <= 40
        && snapshot.cadence is map
        && snapshot.cadence.keys().hasOnly(['interval', 'unit'])
        && snapshot.cadence.interval is int
        && snapshot.cadence.interval > 0
        && snapshot.cadence.unit in ['day', 'week', 'month']
        && validSessionConfig(snapshot.sessionConfig)
        && (
          !('summary' in snapshot)
          || (
            snapshot.summary is string
            && snapshot.summary.size() <= 200
          )
        )
        && (
          !('periodStartPreference' in snapshot)
          || validPeriodStartPreference(snapshot.periodStartPreference)
        );
    }

    function validActivityHistoryDoc() {
      let data = request.resource.data;
      return hasOnlyKeys([
        'id',
        'activityId',
        'standardId',
        'referenceTimestampMs',
        'periodStartMs',
        'periodEndMs',
        'periodLabel',
        'periodKey',
        'standardSnapshot',
        'total',
        'currentSessions',
        'targetSessions',
        'status',
        'progressPercent',
        'generatedAtMs',
        'source'
      ])
      && data.id is string
      && data.id.size() >= 1
      && data.activityId is string
      && data.activityId.size() >= 1
      && data.standardId is string
      && data.standardId.size() >= 1
      && ('referenceTimestampMs' in data)
      && isTimestampMs(data.referenceTimestampMs)
      && (
        !('periodStartMs' in data)
        || isTimestampMs(data.periodStartMs)
      )
      && (
        !('periodEndMs' in data)
        || (
          isTimestampMs(data.periodEndMs)
          && (!('periodStartMs' in data) || data.periodEndMs >= data.periodStartMs)
        )
      )
      && (
        !('periodLabel' in data)
        || (
          data.periodLabel is string
          && data.periodLabel.size() >= 1
          && data.periodLabel.size() <= 200
        )
      )
      && (
        !('periodKey' in data)
        || (
          data.periodKey is string
          && data.periodKey.size() >= 1
          && data.periodKey.size() <= 50
        )
      )
      && data.standardSnapshot is map
      && validActivityHistoryStandardSnapshot(data.standardSnapshot)
      && data.total is number
      && data.total >= 0
      && data.currentSessions is int
      && data.currentSessions >= 0
      && data.targetSessions is int
      && data.targetSessions >= 0
      && data.status in ['Met', 'In Progress', 'Missed']
      && data.progressPercent is number
      && data.progressPercent >= 0
      && data.progressPercent <= 100
      && isTimestampMs(data.generatedAtMs)
      && data.source in ['boundary', 'resume', 'log-edit'];
    }

    function validSnapshotPayload(payload) {
      return payload is map
        && payload.keys().hasOnly(['categories', 'activities', 'standards'])
        && payload.categories is list
        && payload.activities is list
        && payload.standards is list;
    }

    function validSnapshotCreate() {
      return hasOnlyKeys([
        'ownerUserId',
        'title',
        'description',
        'version',
        'isEnabled',
        'payload',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && request.resource.data.ownerUserId is string
      && request.resource.data.ownerUserId.size() >= 1
      && request.resource.data.title is string
      && request.resource.data.title.size() >= 1
      && request.resource.data.title.size() <= 120
      && isOptionalStringField('description')
      && request.resource.data.version is int
      && request.resource.data.version >= 1
      && request.resource.data.isEnabled is bool
      && validSnapshotPayload(request.resource.data.payload)
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('deletedAt');
    }

    function validSnapshotUpdate() {
      let affected = request.resource.data.diff(resource.data).affectedKeys();
      return affected.hasOnly([
        'isEnabled',
        'title',
        'payload',
        'version',
        'updatedAt',
        'deletedAt'
      ])
      && (
        !affected.hasAny(['isEnabled']) || request.resource.data.isEnabled is bool
      )
      && (
        !affected.hasAny(['title']) || (
          request.resource.data.title is string
          && request.resource.data.title.size() >= 1
          && request.resource.data.title.size() <= 120
        )
      )
      && (
        !affected.hasAny(['payload']) || validSnapshotPayload(request.resource.data.payload)
      )
      && (
        !affected.hasAny(['payload']) || affected.hasAny(['version'])
      )
      && (
        !affected.hasAny(['version']) || (
          request.resource.data.version is int
          && request.resource.data.version == resource.data.version + 1
        )
      )
      && (
        !affected.hasAny(['updatedAt']) || request.resource.data.updatedAt == request.time
      )
      && (
        !affected.hasAny(['deletedAt']) || isOptionalTimestampField('deletedAt')
      )
      && request.resource.data.ownerUserId == resource.data.ownerUserId;
    }

    function validShareLinkCreate() {
      return hasOnlyKeys([
        'shareCode',
        'snapshotId',
        'ownerUserId',
        'createdAt',
        'updatedAt',
        'disabledAt'
      ])
      && request.resource.data.shareCode is string
      && request.resource.data.shareCode.size() >= 4
      && request.resource.data.shareCode.size() <= 20
      && request.resource.data.snapshotId is string
      && request.resource.data.snapshotId.size() >= 1
      && request.resource.data.ownerUserId is string
      && request.resource.data.ownerUserId.size() >= 1
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('disabledAt');
    }

    function validShareLinkUpdate() {
      let affected = request.resource.data.diff(resource.data).affectedKeys();
      return affected.hasOnly([
        'shareCode',
        'updatedAt',
        'disabledAt'
      ])
      && (
        !affected.hasAny(['shareCode']) || (
          request.resource.data.shareCode is string
          && request.resource.data.shareCode.size() >= 4
          && request.resource.data.shareCode.size() <= 20
        )
      )
      && (
        !affected.hasAny(['updatedAt']) || request.resource.data.updatedAt == request.time
      )
      && (
        !affected.hasAny(['disabledAt']) || isOptionalTimestampField('disabledAt')
      )
      && request.resource.data.snapshotId == resource.data.snapshotId
      && request.resource.data.ownerUserId == resource.data.ownerUserId;
    }

    function validSnapshotInstallCreate() {
      return hasOnlyKeys([
        'snapshotId',
        'ownerUserId',
        'installedAt'
      ])
      && request.resource.data.snapshotId is string
      && request.resource.data.snapshotId.size() >= 1
      && request.resource.data.ownerUserId is string
      && request.resource.data.ownerUserId.size() >= 1
      && isTimestamp(request.resource.data.installedAt);
    }

    match /users/{uid} {
      allow read: if isOwner(uid);
      // Prevent client from directly writing the user root doc in MVP.
      allow create, update, delete: if false;

      match /activities/{activityId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validActivity() && isCreateWithServerTimestamps();
        allow update: if isOwner(uid) && validActivityUpdate() && isUpdateWithServerTimestampAndStableCreatedAt();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /standards/{standardId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validStandard() && isCreateWithServerTimestamps();
        allow update: if isOwner(uid) && validStandard() && isUpdateWithServerTimestampAndStableCreatedAt() && canWriteStandard();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /categories/{categoryId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validCategory() && isCreateWithServerTimestamps();
        allow update: if isOwner(uid) && validCategoryUpdate() && isUpdateWithServerTimestampAndStableCreatedAt();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /activityLogs/{logId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validActivityLog() && isCreateWithServerTimestamps() && canCreateLogForStandard(uid, request.resource.data.standardId);
        allow update: if isOwner(uid) && validActivityLogUpdate() && isUpdateWithServerTimestampAndStableCreatedAt();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /activityHistory/{historyId} {
        allow read: if isOwner(uid);
        allow create, update: if
          isOwner(uid)
          && validActivityHistoryDoc()
          && request.resource.data.id == historyId;
        allow delete: if false;
      }

      match /preferences/{preferenceId} {
        // Only allow dashboardPins document in preferences collection
        allow read: if isOwner(uid) && preferenceId == 'dashboardPins';
        // Allow create and update (set with merge handles both)
        allow create: if isOwner(uid) && preferenceId == 'dashboardPins' && validDashboardPinsCreate();
        allow update: if isOwner(uid) && preferenceId == 'dashboardPins' && validDashboardPinsUpdate();
        allow delete: if false; // Prevent deletion, use empty array instead
      }

      match /snapshotInstalls/{installId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid)
          && validSnapshotInstallCreate()
          && request.resource.data.installedAt == request.time;
        allow update, delete: if false;
      }
    }

    match /snapshots/{snapshotId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn()
        && request.resource.data.ownerUserId == request.auth.uid
        && validSnapshotCreate()
        && isCreateWithServerTimestamps();
      allow update: if isSignedIn()
        && resource.data.ownerUserId == request.auth.uid
        && validSnapshotUpdate()
        && isUpdateWithServerTimestampAndStableCreatedAt();
      allow delete: if false;
    }

    match /shareLinks/{shareLinkId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn()
        && request.resource.data.ownerUserId == request.auth.uid
        && validShareLinkCreate()
        && isCreateWithServerTimestamps();
      allow update: if isSignedIn()
        && resource.data.ownerUserId == request.auth.uid
        && validShareLinkUpdate()
        && isUpdateWithServerTimestampAndStableCreatedAt();
      allow delete: if false;
    }
  }
}
