rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function hasOnlyKeys(allowedKeys) {
      return request.resource.data.keys().hasOnly(allowedKeys);
    }

    function isTimestamp(value) {
      return value is timestamp;
    }

    function isTimestampMs(value) {
      return value is int && value >= 0;
    }

    function isOptionalTimestampField(fieldName) {
      return !(fieldName in request.resource.data) ||
        request.resource.data[fieldName] == null ||
        isTimestamp(request.resource.data[fieldName]);
    }

    function isOptionalStringField(fieldName) {
      return !(fieldName in request.resource.data) ||
        request.resource.data[fieldName] == null ||
        request.resource.data[fieldName] is string;
    }

    function validSessionConfig(sessionConfig) {
      return sessionConfig is map
        && sessionConfig.keys().hasOnly([
          'sessionLabel',
          'sessionsPerCadence',
          'volumePerSession'
        ])
        && sessionConfig.sessionLabel is string
        && sessionConfig.sessionLabel.size() >= 1
        && sessionConfig.sessionLabel.size() <= 40
        && sessionConfig.sessionsPerCadence is int
        && sessionConfig.sessionsPerCadence >= 1
        && sessionConfig.sessionsPerCadence <= 1000
        && sessionConfig.volumePerSession is number
        && sessionConfig.volumePerSession > 0;
    }

    function validPeriodStartPreference(preference) {
      return preference is map
        && ('mode' in preference)
        && (
          preference.mode == 'default'
          || (
            preference.mode == 'weekDay'
            && 'weekStartDay' in preference
            && preference.weekStartDay is int
            && preference.weekStartDay >= 1
            && preference.weekStartDay <= 7
          )
        );
    }

    function isCreateWithServerTimestamps() {
      // Enforces client use of serverTimestamp(); in rules it resolves to request.time.
      return request.resource.data.createdAt == request.time && request.resource.data.updatedAt == request.time;
    }

    function isUpdateWithServerTimestampAndStableCreatedAt() {
      return request.resource.data.updatedAt == request.time &&
        request.resource.data.createdAt == resource.data.createdAt;
    }

    function validActivity() {
      return hasOnlyKeys([
        'name',
        'unit',
        'notes',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && request.resource.data.name is string
      && request.resource.data.name.size() >= 1
      && request.resource.data.name.size() <= 120
      && request.resource.data.unit is string
      && request.resource.data.unit.size() >= 1
      && request.resource.data.unit.size() <= 40
      && isOptionalStringField('notes')
      && (!('notes' in request.resource.data) || request.resource.data.notes == null || request.resource.data.notes.size() <= 1000)
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('deletedAt');
    }

    // Validation for partial updates (allows updating only specific fields)
    function validActivityUpdate() {
      return hasOnlyKeys([
        'name',
        'unit',
        'notes',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && (!('name' in request.resource.data) || (
        request.resource.data.name is string
        && request.resource.data.name.size() >= 1
        && request.resource.data.name.size() <= 120
      ))
      && (!('unit' in request.resource.data) || (
        request.resource.data.unit is string
        && request.resource.data.unit.size() >= 1
        && request.resource.data.unit.size() <= 40
      ))
      && (!('notes' in request.resource.data) || (
        isOptionalStringField('notes')
        && (request.resource.data.notes == null || request.resource.data.notes.size() <= 1000)
      ))
      && (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt)
      && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt == request.time)
      && (!('deletedAt' in request.resource.data) || isOptionalTimestampField('deletedAt'));
    }

    function validStandard() {
      return hasOnlyKeys([
        'activityId',
        'minimum',
        'unit',
        'cadence',
        'state',
        'summary',
        'sessionConfig',
        'periodStartPreference',
        'quickAddValues',
        'archivedAt',
        'createdAt',
        'updatedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && request.resource.data.activityId is string
      && request.resource.data.activityId.size() >= 1
      && request.resource.data.minimum is number
      && request.resource.data.minimum >= 0
      && request.resource.data.unit is string
      && request.resource.data.unit.size() >= 1
      && request.resource.data.unit.size() <= 40
      && (
        !('quickAddValues' in request.resource.data)
        || (
          request.resource.data.quickAddValues is list
          && request.resource.data.quickAddValues.size() <= 5
        )
      )
      && request.resource.data.cadence is map
      && request.resource.data.cadence.keys().hasOnly(['interval', 'unit'])
      && request.resource.data.cadence.interval is int
      && request.resource.data.cadence.interval > 0
      && request.resource.data.cadence.unit in ['day', 'week', 'month']
      && request.resource.data.state in ['active', 'archived']
      && request.resource.data.summary is string
      && request.resource.data.summary.size() >= 1
      && request.resource.data.summary.size() <= 200
      && ('sessionConfig' in request.resource.data)
      && validSessionConfig(request.resource.data.sessionConfig)
      && (
        !('periodStartPreference' in request.resource.data)
        || validPeriodStartPreference(request.resource.data.periodStartPreference)
      )
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('deletedAt')
      && isOptionalTimestampField('archivedAt');
    }

    // Block writes to Standards that remain archived, while allowing archive + unarchive transitions.
    function canWriteStandard() {
      let wasArchived = resource.data.archivedAt != null;
      let willBeArchived = request.resource.data.archivedAt != null;

      // Writes are always allowed while the standard is active (wasArchived == false).
      // Once archived, the only permitted write is to clear archivedAt (unarchive).
      return !wasArchived || !willBeArchived;
    }

    function validActivityLog() {
      return hasOnlyKeys([
        'standardId',
        'value',
        'occurredAt',
        'note',
        'createdAt',
        'updatedAt',
        'editedAt',
        'deletedAt'
      ])
      && ('deletedAt' in request.resource.data)
      && ('note' in request.resource.data)
      && ('editedAt' in request.resource.data)
      && request.resource.data.standardId is string
      && request.resource.data.standardId.size() >= 1
      && request.resource.data.value is number
      && request.resource.data.value >= 0
      && isTimestamp(request.resource.data.occurredAt)
      && isOptionalStringField('note')
      && isTimestamp(request.resource.data.createdAt)
      && isTimestamp(request.resource.data.updatedAt)
      && isOptionalTimestampField('editedAt')
      && isOptionalTimestampField('deletedAt');
    }

    // Validation for partial updates (allows updating only editedAt/deletedAt/updatedAt and other fields)
    function validActivityLogUpdate() {
      return hasOnlyKeys([
        'standardId',
        'value',
        'occurredAt',
        'note',
        'createdAt',
        'updatedAt',
        'editedAt',
        'deletedAt'
      ])
      && (!('standardId' in request.resource.data) || (
        request.resource.data.standardId is string
        && request.resource.data.standardId.size() >= 1
        && request.resource.data.standardId == resource.data.standardId
      ))
      && (!('value' in request.resource.data) || (
        request.resource.data.value is number
        && request.resource.data.value >= 0
      ))
      && (!('occurredAt' in request.resource.data) || isTimestamp(request.resource.data.occurredAt))
      && (!('note' in request.resource.data) || isOptionalStringField('note'))
      && (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt)
      && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt == request.time)
      && (!('editedAt' in request.resource.data) || isOptionalTimestampField('editedAt'))
      && (!('deletedAt' in request.resource.data) || isOptionalTimestampField('deletedAt'));
    }

    function canCreateLogForStandard(uid, standardId) {
      let standardDoc = get(/databases/$(database)/documents/users/$(uid)/standards/$(standardId));
      return standardDoc.data != null && standardDoc.data.archivedAt == null;
    }

    function validDashboardPins() {
      return hasOnlyKeys([
        'pinnedStandardIds',
        'updatedAt'
      ])
      && ('pinnedStandardIds' in request.resource.data)
      && request.resource.data.pinnedStandardIds is list
      && request.resource.data.pinnedStandardIds.size() <= 1000
      && ('updatedAt' in request.resource.data)
      && isTimestamp(request.resource.data.updatedAt);
    }

    function validDashboardPinsCreate() {
      // For creates, updatedAt must be set to request.time (serverTimestamp)
      return validDashboardPins() && 
        request.resource.data.updatedAt == request.time;
    }

    function validDashboardPinsUpdate() {
      // For updates, updatedAt must be set to request.time (serverTimestamp)
      // pinnedStandardIds can be updated
      return validDashboardPins() && 
        request.resource.data.updatedAt == request.time;
    }

    function validActivityHistoryStandardSnapshot(snapshot) {
      return snapshot is map
        && snapshot.keys().hasOnly([
          'minimum',
          'unit',
          'cadence',
          'sessionConfig',
          'summary',
          'periodStartPreference'
        ])
        && snapshot.minimum is number
        && snapshot.minimum >= 0
        && snapshot.unit is string
        && snapshot.unit.size() >= 1
        && snapshot.unit.size() <= 40
        && snapshot.cadence is map
        && snapshot.cadence.keys().hasOnly(['interval', 'unit'])
        && snapshot.cadence.interval is int
        && snapshot.cadence.interval > 0
        && snapshot.cadence.unit in ['day', 'week', 'month']
        && validSessionConfig(snapshot.sessionConfig)
        && (
          !('summary' in snapshot)
          || (
            snapshot.summary is string
            && snapshot.summary.size() <= 200
          )
        )
        && (
          !('periodStartPreference' in snapshot)
          || validPeriodStartPreference(snapshot.periodStartPreference)
        );
    }

    function validActivityHistoryDoc() {
      let data = request.resource.data;
      return hasOnlyKeys([
        'id',
        'activityId',
        'standardId',
        'referenceTimestampMs',
        'periodStartMs',
        'periodEndMs',
        'periodLabel',
        'periodKey',
        'standardSnapshot',
        'total',
        'currentSessions',
        'targetSessions',
        'status',
        'progressPercent',
        'generatedAtMs',
        'source'
      ])
      && data.id is string
      && data.id.size() >= 1
      && data.activityId is string
      && data.activityId.size() >= 1
      && data.standardId is string
      && data.standardId.size() >= 1
      && ('referenceTimestampMs' in data)
      && isTimestampMs(data.referenceTimestampMs)
      && (
        !('periodStartMs' in data)
        || isTimestampMs(data.periodStartMs)
      )
      && (
        !('periodEndMs' in data)
        || (
          isTimestampMs(data.periodEndMs)
          && (!('periodStartMs' in data) || data.periodEndMs >= data.periodStartMs)
        )
      )
      && (
        !('periodLabel' in data)
        || (
          data.periodLabel is string
          && data.periodLabel.size() >= 1
          && data.periodLabel.size() <= 200
        )
      )
      && (
        !('periodKey' in data)
        || (
          data.periodKey is string
          && data.periodKey.size() >= 1
          && data.periodKey.size() <= 50
        )
      )
      && data.standardSnapshot is map
      && validActivityHistoryStandardSnapshot(data.standardSnapshot)
      && data.total is number
      && data.total >= 0
      && data.currentSessions is int
      && data.currentSessions >= 0
      && data.targetSessions is int
      && data.targetSessions > 0
      && data.status in ['Met', 'In Progress', 'Missed']
      && data.progressPercent is number
      && data.progressPercent >= 0
      && data.progressPercent <= 100
      && isTimestampMs(data.generatedAtMs)
      && data.source in ['boundary', 'resume'];
    }

    match /users/{uid} {
      allow read: if isOwner(uid);
      // Prevent client from directly writing the user root doc in MVP.
      allow create, update, delete: if false;

      match /activities/{activityId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validActivity() && isCreateWithServerTimestamps();
        allow update: if isOwner(uid) && validActivityUpdate() && isUpdateWithServerTimestampAndStableCreatedAt();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /standards/{standardId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validStandard() && isCreateWithServerTimestamps();
        allow update: if isOwner(uid) && validStandard() && isUpdateWithServerTimestampAndStableCreatedAt() && canWriteStandard();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /activityLogs/{logId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid) && validActivityLog() && isCreateWithServerTimestamps() && canCreateLogForStandard(uid, request.resource.data.standardId);
        allow update: if isOwner(uid) && validActivityLogUpdate() && isUpdateWithServerTimestampAndStableCreatedAt();
        allow delete: if false; // soft-delete via deletedAt
      }

      match /activityHistory/{historyId} {
        allow read: if isOwner(uid);
        allow create, update: if
          isOwner(uid)
          && validActivityHistoryDoc()
          && request.resource.data.id == historyId;
        allow delete: if false;
      }

      match /preferences/{preferenceId} {
        // Only allow dashboardPins document in preferences collection
        allow read: if isOwner(uid) && preferenceId == 'dashboardPins';
        // Allow create and update (set with merge handles both)
        allow create: if isOwner(uid) && preferenceId == 'dashboardPins' && validDashboardPinsCreate();
        allow update: if isOwner(uid) && preferenceId == 'dashboardPins' && validDashboardPinsUpdate();
        allow delete: if false; // Prevent deletion, use empty array instead
      }
    }
  }
}
